// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/thoohv5/template/internal/ent/miniprogramaccount"
	"github.com/thoohv5/template/internal/ent/phoneaccount"
	"github.com/thoohv5/template/internal/ent/user"
	"github.com/thoohv5/template/internal/ent/useraccount"
	"github.com/thoohv5/template/internal/ent/userextend"
	"github.com/thoohv5/template/internal/ent/userinfo"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMiniProgramAccount = "MiniProgramAccount"
	TypePhoneAccount       = "PhoneAccount"
	TypeUser               = "User"
	TypeUserAccount        = "UserAccount"
	TypeUserExtend         = "UserExtend"
	TypeUserInfo           = "UserInfo"
)

// MiniProgramAccountMutation represents an operation that mutate the MiniProgramAccounts
// nodes in the graph.
type MiniProgramAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	user_identity *string
	open_id       *string
	nick_name     *string
	avatar_url    *string
	gender        *int32
	addgender     *int32
	country       *string
	province      *string
	city          *string
	language      *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MiniProgramAccount, error)
}

var _ ent.Mutation = (*MiniProgramAccountMutation)(nil)

// miniprogramaccountOption allows to manage the mutation configuration using functional options.
type miniprogramaccountOption func(*MiniProgramAccountMutation)

// newMiniProgramAccountMutation creates new mutation for $n.Name.
func newMiniProgramAccountMutation(c config, op Op, opts ...miniprogramaccountOption) *MiniProgramAccountMutation {
	m := &MiniProgramAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeMiniProgramAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMiniProgramAccountID sets the id field of the mutation.
func withMiniProgramAccountID(id int64) miniprogramaccountOption {
	return func(m *MiniProgramAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *MiniProgramAccount
		)
		m.oldValue = func(ctx context.Context) (*MiniProgramAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MiniProgramAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMiniProgramAccount sets the old MiniProgramAccount of the mutation.
func withMiniProgramAccount(node *MiniProgramAccount) miniprogramaccountOption {
	return func(m *MiniProgramAccountMutation) {
		m.oldValue = func(context.Context) (*MiniProgramAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MiniProgramAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MiniProgramAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on MiniProgramAccount creation.
func (m *MiniProgramAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MiniProgramAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserIdentity sets the user_identity field.
func (m *MiniProgramAccountMutation) SetUserIdentity(s string) {
	m.user_identity = &s
}

// UserIdentity returns the user_identity value in the mutation.
func (m *MiniProgramAccountMutation) UserIdentity() (r string, exists bool) {
	v := m.user_identity
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIdentity returns the old user_identity value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldUserIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserIdentity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIdentity: %w", err)
	}
	return oldValue.UserIdentity, nil
}

// ClearUserIdentity clears the value of user_identity.
func (m *MiniProgramAccountMutation) ClearUserIdentity() {
	m.user_identity = nil
	m.clearedFields[miniprogramaccount.FieldUserIdentity] = struct{}{}
}

// UserIdentityCleared returns if the field user_identity was cleared in this mutation.
func (m *MiniProgramAccountMutation) UserIdentityCleared() bool {
	_, ok := m.clearedFields[miniprogramaccount.FieldUserIdentity]
	return ok
}

// ResetUserIdentity reset all changes of the "user_identity" field.
func (m *MiniProgramAccountMutation) ResetUserIdentity() {
	m.user_identity = nil
	delete(m.clearedFields, miniprogramaccount.FieldUserIdentity)
}

// SetOpenID sets the open_id field.
func (m *MiniProgramAccountMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the open_id value in the mutation.
func (m *MiniProgramAccountMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old open_id value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpenID is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ClearOpenID clears the value of open_id.
func (m *MiniProgramAccountMutation) ClearOpenID() {
	m.open_id = nil
	m.clearedFields[miniprogramaccount.FieldOpenID] = struct{}{}
}

// OpenIDCleared returns if the field open_id was cleared in this mutation.
func (m *MiniProgramAccountMutation) OpenIDCleared() bool {
	_, ok := m.clearedFields[miniprogramaccount.FieldOpenID]
	return ok
}

// ResetOpenID reset all changes of the "open_id" field.
func (m *MiniProgramAccountMutation) ResetOpenID() {
	m.open_id = nil
	delete(m.clearedFields, miniprogramaccount.FieldOpenID)
}

// SetNickName sets the nick_name field.
func (m *MiniProgramAccountMutation) SetNickName(s string) {
	m.nick_name = &s
}

// NickName returns the nick_name value in the mutation.
func (m *MiniProgramAccountMutation) NickName() (r string, exists bool) {
	v := m.nick_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old nick_name value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ResetNickName reset all changes of the "nick_name" field.
func (m *MiniProgramAccountMutation) ResetNickName() {
	m.nick_name = nil
}

// SetAvatarURL sets the avatar_url field.
func (m *MiniProgramAccountMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the avatar_url value in the mutation.
func (m *MiniProgramAccountMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old avatar_url value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatarURL is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL reset all changes of the "avatar_url" field.
func (m *MiniProgramAccountMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetGender sets the gender field.
func (m *MiniProgramAccountMutation) SetGender(i int32) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the gender value in the mutation.
func (m *MiniProgramAccountMutation) Gender() (r int32, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old gender value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldGender(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to gender.
func (m *MiniProgramAccountMutation) AddGender(i int32) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the gender field in this mutation.
func (m *MiniProgramAccountMutation) AddedGender() (r int32, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender reset all changes of the "gender" field.
func (m *MiniProgramAccountMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetCountry sets the country field.
func (m *MiniProgramAccountMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the country value in the mutation.
func (m *MiniProgramAccountMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old country value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCountry is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry reset all changes of the "country" field.
func (m *MiniProgramAccountMutation) ResetCountry() {
	m.country = nil
}

// SetProvince sets the province field.
func (m *MiniProgramAccountMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the province value in the mutation.
func (m *MiniProgramAccountMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old province value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince reset all changes of the "province" field.
func (m *MiniProgramAccountMutation) ResetProvince() {
	m.province = nil
}

// SetCity sets the city field.
func (m *MiniProgramAccountMutation) SetCity(s string) {
	m.city = &s
}

// City returns the city value in the mutation.
func (m *MiniProgramAccountMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old city value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity reset all changes of the "city" field.
func (m *MiniProgramAccountMutation) ResetCity() {
	m.city = nil
}

// SetLanguage sets the language field.
func (m *MiniProgramAccountMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the language value in the mutation.
func (m *MiniProgramAccountMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old language value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLanguage is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage reset all changes of the "language" field.
func (m *MiniProgramAccountMutation) ResetLanguage() {
	m.language = nil
}

// SetCreatedAt sets the created_at field.
func (m *MiniProgramAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *MiniProgramAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of created_at.
func (m *MiniProgramAccountMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[miniprogramaccount.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field created_at was cleared in this mutation.
func (m *MiniProgramAccountMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[miniprogramaccount.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *MiniProgramAccountMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, miniprogramaccount.FieldCreatedAt)
}

// SetUpdatedAt sets the updated_at field.
func (m *MiniProgramAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *MiniProgramAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of updated_at.
func (m *MiniProgramAccountMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[miniprogramaccount.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updated_at was cleared in this mutation.
func (m *MiniProgramAccountMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[miniprogramaccount.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *MiniProgramAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, miniprogramaccount.FieldUpdatedAt)
}

// SetDeletedAt sets the deleted_at field.
func (m *MiniProgramAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *MiniProgramAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the MiniProgramAccount.
// If the MiniProgramAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MiniProgramAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *MiniProgramAccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[miniprogramaccount.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *MiniProgramAccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[miniprogramaccount.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *MiniProgramAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, miniprogramaccount.FieldDeletedAt)
}

// Op returns the operation name.
func (m *MiniProgramAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MiniProgramAccount).
func (m *MiniProgramAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MiniProgramAccountMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.user_identity != nil {
		fields = append(fields, miniprogramaccount.FieldUserIdentity)
	}
	if m.open_id != nil {
		fields = append(fields, miniprogramaccount.FieldOpenID)
	}
	if m.nick_name != nil {
		fields = append(fields, miniprogramaccount.FieldNickName)
	}
	if m.avatar_url != nil {
		fields = append(fields, miniprogramaccount.FieldAvatarURL)
	}
	if m.gender != nil {
		fields = append(fields, miniprogramaccount.FieldGender)
	}
	if m.country != nil {
		fields = append(fields, miniprogramaccount.FieldCountry)
	}
	if m.province != nil {
		fields = append(fields, miniprogramaccount.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, miniprogramaccount.FieldCity)
	}
	if m.language != nil {
		fields = append(fields, miniprogramaccount.FieldLanguage)
	}
	if m.created_at != nil {
		fields = append(fields, miniprogramaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, miniprogramaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, miniprogramaccount.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MiniProgramAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case miniprogramaccount.FieldUserIdentity:
		return m.UserIdentity()
	case miniprogramaccount.FieldOpenID:
		return m.OpenID()
	case miniprogramaccount.FieldNickName:
		return m.NickName()
	case miniprogramaccount.FieldAvatarURL:
		return m.AvatarURL()
	case miniprogramaccount.FieldGender:
		return m.Gender()
	case miniprogramaccount.FieldCountry:
		return m.Country()
	case miniprogramaccount.FieldProvince:
		return m.Province()
	case miniprogramaccount.FieldCity:
		return m.City()
	case miniprogramaccount.FieldLanguage:
		return m.Language()
	case miniprogramaccount.FieldCreatedAt:
		return m.CreatedAt()
	case miniprogramaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case miniprogramaccount.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MiniProgramAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case miniprogramaccount.FieldUserIdentity:
		return m.OldUserIdentity(ctx)
	case miniprogramaccount.FieldOpenID:
		return m.OldOpenID(ctx)
	case miniprogramaccount.FieldNickName:
		return m.OldNickName(ctx)
	case miniprogramaccount.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case miniprogramaccount.FieldGender:
		return m.OldGender(ctx)
	case miniprogramaccount.FieldCountry:
		return m.OldCountry(ctx)
	case miniprogramaccount.FieldProvince:
		return m.OldProvince(ctx)
	case miniprogramaccount.FieldCity:
		return m.OldCity(ctx)
	case miniprogramaccount.FieldLanguage:
		return m.OldLanguage(ctx)
	case miniprogramaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case miniprogramaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case miniprogramaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MiniProgramAccount field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MiniProgramAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case miniprogramaccount.FieldUserIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIdentity(v)
		return nil
	case miniprogramaccount.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case miniprogramaccount.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case miniprogramaccount.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case miniprogramaccount.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case miniprogramaccount.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case miniprogramaccount.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case miniprogramaccount.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case miniprogramaccount.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case miniprogramaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case miniprogramaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case miniprogramaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MiniProgramAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MiniProgramAccountMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, miniprogramaccount.FieldGender)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MiniProgramAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case miniprogramaccount.FieldGender:
		return m.AddedGender()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MiniProgramAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case miniprogramaccount.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	}
	return fmt.Errorf("unknown MiniProgramAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MiniProgramAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(miniprogramaccount.FieldUserIdentity) {
		fields = append(fields, miniprogramaccount.FieldUserIdentity)
	}
	if m.FieldCleared(miniprogramaccount.FieldOpenID) {
		fields = append(fields, miniprogramaccount.FieldOpenID)
	}
	if m.FieldCleared(miniprogramaccount.FieldCreatedAt) {
		fields = append(fields, miniprogramaccount.FieldCreatedAt)
	}
	if m.FieldCleared(miniprogramaccount.FieldUpdatedAt) {
		fields = append(fields, miniprogramaccount.FieldUpdatedAt)
	}
	if m.FieldCleared(miniprogramaccount.FieldDeletedAt) {
		fields = append(fields, miniprogramaccount.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MiniProgramAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MiniProgramAccountMutation) ClearField(name string) error {
	switch name {
	case miniprogramaccount.FieldUserIdentity:
		m.ClearUserIdentity()
		return nil
	case miniprogramaccount.FieldOpenID:
		m.ClearOpenID()
		return nil
	case miniprogramaccount.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case miniprogramaccount.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case miniprogramaccount.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown MiniProgramAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MiniProgramAccountMutation) ResetField(name string) error {
	switch name {
	case miniprogramaccount.FieldUserIdentity:
		m.ResetUserIdentity()
		return nil
	case miniprogramaccount.FieldOpenID:
		m.ResetOpenID()
		return nil
	case miniprogramaccount.FieldNickName:
		m.ResetNickName()
		return nil
	case miniprogramaccount.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case miniprogramaccount.FieldGender:
		m.ResetGender()
		return nil
	case miniprogramaccount.FieldCountry:
		m.ResetCountry()
		return nil
	case miniprogramaccount.FieldProvince:
		m.ResetProvince()
		return nil
	case miniprogramaccount.FieldCity:
		m.ResetCity()
		return nil
	case miniprogramaccount.FieldLanguage:
		m.ResetLanguage()
		return nil
	case miniprogramaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case miniprogramaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case miniprogramaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown MiniProgramAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MiniProgramAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MiniProgramAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MiniProgramAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MiniProgramAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MiniProgramAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MiniProgramAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MiniProgramAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MiniProgramAccount unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MiniProgramAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MiniProgramAccount edge %s", name)
}

// PhoneAccountMutation represents an operation that mutate the PhoneAccounts
// nodes in the graph.
type PhoneAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	user_identity *string
	phone         *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PhoneAccount, error)
}

var _ ent.Mutation = (*PhoneAccountMutation)(nil)

// phoneaccountOption allows to manage the mutation configuration using functional options.
type phoneaccountOption func(*PhoneAccountMutation)

// newPhoneAccountMutation creates new mutation for $n.Name.
func newPhoneAccountMutation(c config, op Op, opts ...phoneaccountOption) *PhoneAccountMutation {
	m := &PhoneAccountMutation{
		config:        c,
		op:            op,
		typ:           TypePhoneAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhoneAccountID sets the id field of the mutation.
func withPhoneAccountID(id int64) phoneaccountOption {
	return func(m *PhoneAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *PhoneAccount
		)
		m.oldValue = func(ctx context.Context) (*PhoneAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PhoneAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhoneAccount sets the old PhoneAccount of the mutation.
func withPhoneAccount(node *PhoneAccount) phoneaccountOption {
	return func(m *PhoneAccountMutation) {
		m.oldValue = func(context.Context) (*PhoneAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhoneAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhoneAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on PhoneAccount creation.
func (m *PhoneAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PhoneAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserIdentity sets the user_identity field.
func (m *PhoneAccountMutation) SetUserIdentity(s string) {
	m.user_identity = &s
}

// UserIdentity returns the user_identity value in the mutation.
func (m *PhoneAccountMutation) UserIdentity() (r string, exists bool) {
	v := m.user_identity
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIdentity returns the old user_identity value of the PhoneAccount.
// If the PhoneAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PhoneAccountMutation) OldUserIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserIdentity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIdentity: %w", err)
	}
	return oldValue.UserIdentity, nil
}

// ClearUserIdentity clears the value of user_identity.
func (m *PhoneAccountMutation) ClearUserIdentity() {
	m.user_identity = nil
	m.clearedFields[phoneaccount.FieldUserIdentity] = struct{}{}
}

// UserIdentityCleared returns if the field user_identity was cleared in this mutation.
func (m *PhoneAccountMutation) UserIdentityCleared() bool {
	_, ok := m.clearedFields[phoneaccount.FieldUserIdentity]
	return ok
}

// ResetUserIdentity reset all changes of the "user_identity" field.
func (m *PhoneAccountMutation) ResetUserIdentity() {
	m.user_identity = nil
	delete(m.clearedFields, phoneaccount.FieldUserIdentity)
}

// SetPhone sets the phone field.
func (m *PhoneAccountMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the phone value in the mutation.
func (m *PhoneAccountMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old phone value of the PhoneAccount.
// If the PhoneAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PhoneAccountMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of phone.
func (m *PhoneAccountMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[phoneaccount.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the field phone was cleared in this mutation.
func (m *PhoneAccountMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[phoneaccount.FieldPhone]
	return ok
}

// ResetPhone reset all changes of the "phone" field.
func (m *PhoneAccountMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, phoneaccount.FieldPhone)
}

// SetCreatedAt sets the created_at field.
func (m *PhoneAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *PhoneAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the PhoneAccount.
// If the PhoneAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PhoneAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of created_at.
func (m *PhoneAccountMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[phoneaccount.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field created_at was cleared in this mutation.
func (m *PhoneAccountMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[phoneaccount.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *PhoneAccountMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, phoneaccount.FieldCreatedAt)
}

// SetUpdatedAt sets the updated_at field.
func (m *PhoneAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *PhoneAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the PhoneAccount.
// If the PhoneAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PhoneAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of updated_at.
func (m *PhoneAccountMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[phoneaccount.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updated_at was cleared in this mutation.
func (m *PhoneAccountMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[phoneaccount.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *PhoneAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, phoneaccount.FieldUpdatedAt)
}

// SetDeletedAt sets the deleted_at field.
func (m *PhoneAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *PhoneAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the PhoneAccount.
// If the PhoneAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PhoneAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *PhoneAccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[phoneaccount.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *PhoneAccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[phoneaccount.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *PhoneAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, phoneaccount.FieldDeletedAt)
}

// Op returns the operation name.
func (m *PhoneAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PhoneAccount).
func (m *PhoneAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PhoneAccountMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_identity != nil {
		fields = append(fields, phoneaccount.FieldUserIdentity)
	}
	if m.phone != nil {
		fields = append(fields, phoneaccount.FieldPhone)
	}
	if m.created_at != nil {
		fields = append(fields, phoneaccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, phoneaccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, phoneaccount.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PhoneAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case phoneaccount.FieldUserIdentity:
		return m.UserIdentity()
	case phoneaccount.FieldPhone:
		return m.Phone()
	case phoneaccount.FieldCreatedAt:
		return m.CreatedAt()
	case phoneaccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case phoneaccount.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PhoneAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case phoneaccount.FieldUserIdentity:
		return m.OldUserIdentity(ctx)
	case phoneaccount.FieldPhone:
		return m.OldPhone(ctx)
	case phoneaccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case phoneaccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case phoneaccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PhoneAccount field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PhoneAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case phoneaccount.FieldUserIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIdentity(v)
		return nil
	case phoneaccount.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case phoneaccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case phoneaccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case phoneaccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PhoneAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PhoneAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PhoneAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PhoneAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PhoneAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PhoneAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(phoneaccount.FieldUserIdentity) {
		fields = append(fields, phoneaccount.FieldUserIdentity)
	}
	if m.FieldCleared(phoneaccount.FieldPhone) {
		fields = append(fields, phoneaccount.FieldPhone)
	}
	if m.FieldCleared(phoneaccount.FieldCreatedAt) {
		fields = append(fields, phoneaccount.FieldCreatedAt)
	}
	if m.FieldCleared(phoneaccount.FieldUpdatedAt) {
		fields = append(fields, phoneaccount.FieldUpdatedAt)
	}
	if m.FieldCleared(phoneaccount.FieldDeletedAt) {
		fields = append(fields, phoneaccount.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PhoneAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhoneAccountMutation) ClearField(name string) error {
	switch name {
	case phoneaccount.FieldUserIdentity:
		m.ClearUserIdentity()
		return nil
	case phoneaccount.FieldPhone:
		m.ClearPhone()
		return nil
	case phoneaccount.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case phoneaccount.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case phoneaccount.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PhoneAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PhoneAccountMutation) ResetField(name string) error {
	switch name {
	case phoneaccount.FieldUserIdentity:
		m.ResetUserIdentity()
		return nil
	case phoneaccount.FieldPhone:
		m.ResetPhone()
		return nil
	case phoneaccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case phoneaccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case phoneaccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown PhoneAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PhoneAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PhoneAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PhoneAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PhoneAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PhoneAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PhoneAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PhoneAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PhoneAccount unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PhoneAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PhoneAccount edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	identity      *string
	_type         *int32
	add_type      *int32
	is_disable    *int32
	addis_disable *int32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on User creation.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetIdentity sets the identity field.
func (m *UserMutation) SetIdentity(s string) {
	m.identity = &s
}

// Identity returns the identity value in the mutation.
func (m *UserMutation) Identity() (r string, exists bool) {
	v := m.identity
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentity returns the old identity value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIdentity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentity: %w", err)
	}
	return oldValue.Identity, nil
}

// ClearIdentity clears the value of identity.
func (m *UserMutation) ClearIdentity() {
	m.identity = nil
	m.clearedFields[user.FieldIdentity] = struct{}{}
}

// IdentityCleared returns if the field identity was cleared in this mutation.
func (m *UserMutation) IdentityCleared() bool {
	_, ok := m.clearedFields[user.FieldIdentity]
	return ok
}

// ResetIdentity reset all changes of the "identity" field.
func (m *UserMutation) ResetIdentity() {
	m.identity = nil
	delete(m.clearedFields, user.FieldIdentity)
}

// SetType sets the type field.
func (m *UserMutation) SetType(i int32) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the type value in the mutation.
func (m *UserMutation) GetType() (r int32, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old type value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to type.
func (m *UserMutation) AddType(i int32) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the type field in this mutation.
func (m *UserMutation) AddedType() (r int32, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType reset all changes of the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetIsDisable sets the is_disable field.
func (m *UserMutation) SetIsDisable(i int32) {
	m.is_disable = &i
	m.addis_disable = nil
}

// IsDisable returns the is_disable value in the mutation.
func (m *UserMutation) IsDisable() (r int32, exists bool) {
	v := m.is_disable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisable returns the old is_disable value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldIsDisable(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDisable is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDisable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisable: %w", err)
	}
	return oldValue.IsDisable, nil
}

// AddIsDisable adds i to is_disable.
func (m *UserMutation) AddIsDisable(i int32) {
	if m.addis_disable != nil {
		*m.addis_disable += i
	} else {
		m.addis_disable = &i
	}
}

// AddedIsDisable returns the value that was added to the is_disable field in this mutation.
func (m *UserMutation) AddedIsDisable() (r int32, exists bool) {
	v := m.addis_disable
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsDisable reset all changes of the "is_disable" field.
func (m *UserMutation) ResetIsDisable() {
	m.is_disable = nil
	m.addis_disable = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of created_at.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field created_at was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the updated_at field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of updated_at.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updated_at was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetDeletedAt sets the deleted_at field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.identity != nil {
		fields = append(fields, user.FieldIdentity)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.is_disable != nil {
		fields = append(fields, user.FieldIsDisable)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldIdentity:
		return m.Identity()
	case user.FieldType:
		return m.GetType()
	case user.FieldIsDisable:
		return m.IsDisable()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldIdentity:
		return m.OldIdentity(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	case user.FieldIsDisable:
		return m.OldIsDisable(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentity(v)
		return nil
	case user.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldIsDisable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisable(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.addis_disable != nil {
		fields = append(fields, user.FieldIsDisable)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldType:
		return m.AddedType()
	case user.FieldIsDisable:
		return m.AddedIsDisable()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case user.FieldIsDisable:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsDisable(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldIdentity) {
		fields = append(fields, user.FieldIdentity)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldIdentity:
		m.ClearIdentity()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldIdentity:
		m.ResetIdentity()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldIsDisable:
		m.ResetIsDisable()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAccountMutation represents an operation that mutate the UserAccounts
// nodes in the graph.
type UserAccountMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	user_identity *string
	account       *int64
	addaccount    *int64
	password      *string
	salt          *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserAccount, error)
}

var _ ent.Mutation = (*UserAccountMutation)(nil)

// useraccountOption allows to manage the mutation configuration using functional options.
type useraccountOption func(*UserAccountMutation)

// newUserAccountMutation creates new mutation for $n.Name.
func newUserAccountMutation(c config, op Op, opts ...useraccountOption) *UserAccountMutation {
	m := &UserAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAccountID sets the id field of the mutation.
func withUserAccountID(id int64) useraccountOption {
	return func(m *UserAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAccount
		)
		m.oldValue = func(ctx context.Context) (*UserAccount, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAccount sets the old UserAccount of the mutation.
func withUserAccount(node *UserAccount) useraccountOption {
	return func(m *UserAccountMutation) {
		m.oldValue = func(context.Context) (*UserAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on UserAccount creation.
func (m *UserAccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserAccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserIdentity sets the user_identity field.
func (m *UserAccountMutation) SetUserIdentity(s string) {
	m.user_identity = &s
}

// UserIdentity returns the user_identity value in the mutation.
func (m *UserAccountMutation) UserIdentity() (r string, exists bool) {
	v := m.user_identity
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIdentity returns the old user_identity value of the UserAccount.
// If the UserAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserAccountMutation) OldUserIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserIdentity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIdentity: %w", err)
	}
	return oldValue.UserIdentity, nil
}

// ClearUserIdentity clears the value of user_identity.
func (m *UserAccountMutation) ClearUserIdentity() {
	m.user_identity = nil
	m.clearedFields[useraccount.FieldUserIdentity] = struct{}{}
}

// UserIdentityCleared returns if the field user_identity was cleared in this mutation.
func (m *UserAccountMutation) UserIdentityCleared() bool {
	_, ok := m.clearedFields[useraccount.FieldUserIdentity]
	return ok
}

// ResetUserIdentity reset all changes of the "user_identity" field.
func (m *UserAccountMutation) ResetUserIdentity() {
	m.user_identity = nil
	delete(m.clearedFields, useraccount.FieldUserIdentity)
}

// SetAccount sets the account field.
func (m *UserAccountMutation) SetAccount(i int64) {
	m.account = &i
	m.addaccount = nil
}

// Account returns the account value in the mutation.
func (m *UserAccountMutation) Account() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old account value of the UserAccount.
// If the UserAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserAccountMutation) OldAccount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// AddAccount adds i to account.
func (m *UserAccountMutation) AddAccount(i int64) {
	if m.addaccount != nil {
		*m.addaccount += i
	} else {
		m.addaccount = &i
	}
}

// AddedAccount returns the value that was added to the account field in this mutation.
func (m *UserAccountMutation) AddedAccount() (r int64, exists bool) {
	v := m.addaccount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccount clears the value of account.
func (m *UserAccountMutation) ClearAccount() {
	m.account = nil
	m.addaccount = nil
	m.clearedFields[useraccount.FieldAccount] = struct{}{}
}

// AccountCleared returns if the field account was cleared in this mutation.
func (m *UserAccountMutation) AccountCleared() bool {
	_, ok := m.clearedFields[useraccount.FieldAccount]
	return ok
}

// ResetAccount reset all changes of the "account" field.
func (m *UserAccountMutation) ResetAccount() {
	m.account = nil
	m.addaccount = nil
	delete(m.clearedFields, useraccount.FieldAccount)
}

// SetPassword sets the password field.
func (m *UserAccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserAccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the UserAccount.
// If the UserAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserAccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserAccountMutation) ResetPassword() {
	m.password = nil
}

// SetSalt sets the salt field.
func (m *UserAccountMutation) SetSalt(s string) {
	m.salt = &s
}

// Salt returns the salt value in the mutation.
func (m *UserAccountMutation) Salt() (r string, exists bool) {
	v := m.salt
	if v == nil {
		return
	}
	return *v, true
}

// OldSalt returns the old salt value of the UserAccount.
// If the UserAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserAccountMutation) OldSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSalt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalt: %w", err)
	}
	return oldValue.Salt, nil
}

// ResetSalt reset all changes of the "salt" field.
func (m *UserAccountMutation) ResetSalt() {
	m.salt = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the UserAccount.
// If the UserAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of created_at.
func (m *UserAccountMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[useraccount.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field created_at was cleared in this mutation.
func (m *UserAccountMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[useraccount.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserAccountMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, useraccount.FieldCreatedAt)
}

// SetUpdatedAt sets the updated_at field.
func (m *UserAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the UserAccount.
// If the UserAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of updated_at.
func (m *UserAccountMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[useraccount.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updated_at was cleared in this mutation.
func (m *UserAccountMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[useraccount.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, useraccount.FieldUpdatedAt)
}

// SetDeletedAt sets the deleted_at field.
func (m *UserAccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserAccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the UserAccount.
// If the UserAccount object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserAccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserAccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[useraccount.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserAccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[useraccount.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *UserAccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, useraccount.FieldDeletedAt)
}

// Op returns the operation name.
func (m *UserAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserAccount).
func (m *UserAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserAccountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_identity != nil {
		fields = append(fields, useraccount.FieldUserIdentity)
	}
	if m.account != nil {
		fields = append(fields, useraccount.FieldAccount)
	}
	if m.password != nil {
		fields = append(fields, useraccount.FieldPassword)
	}
	if m.salt != nil {
		fields = append(fields, useraccount.FieldSalt)
	}
	if m.created_at != nil {
		fields = append(fields, useraccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, useraccount.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, useraccount.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useraccount.FieldUserIdentity:
		return m.UserIdentity()
	case useraccount.FieldAccount:
		return m.Account()
	case useraccount.FieldPassword:
		return m.Password()
	case useraccount.FieldSalt:
		return m.Salt()
	case useraccount.FieldCreatedAt:
		return m.CreatedAt()
	case useraccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case useraccount.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useraccount.FieldUserIdentity:
		return m.OldUserIdentity(ctx)
	case useraccount.FieldAccount:
		return m.OldAccount(ctx)
	case useraccount.FieldPassword:
		return m.OldPassword(ctx)
	case useraccount.FieldSalt:
		return m.OldSalt(ctx)
	case useraccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useraccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case useraccount.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserAccount field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useraccount.FieldUserIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIdentity(v)
		return nil
	case useraccount.FieldAccount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case useraccount.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case useraccount.FieldSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalt(v)
		return nil
	case useraccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useraccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case useraccount.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserAccountMutation) AddedFields() []string {
	var fields []string
	if m.addaccount != nil {
		fields = append(fields, useraccount.FieldAccount)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case useraccount.FieldAccount:
		return m.AddedAccount()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case useraccount.FieldAccount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccount(v)
		return nil
	}
	return fmt.Errorf("unknown UserAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useraccount.FieldUserIdentity) {
		fields = append(fields, useraccount.FieldUserIdentity)
	}
	if m.FieldCleared(useraccount.FieldAccount) {
		fields = append(fields, useraccount.FieldAccount)
	}
	if m.FieldCleared(useraccount.FieldCreatedAt) {
		fields = append(fields, useraccount.FieldCreatedAt)
	}
	if m.FieldCleared(useraccount.FieldUpdatedAt) {
		fields = append(fields, useraccount.FieldUpdatedAt)
	}
	if m.FieldCleared(useraccount.FieldDeletedAt) {
		fields = append(fields, useraccount.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAccountMutation) ClearField(name string) error {
	switch name {
	case useraccount.FieldUserIdentity:
		m.ClearUserIdentity()
		return nil
	case useraccount.FieldAccount:
		m.ClearAccount()
		return nil
	case useraccount.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case useraccount.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case useraccount.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserAccountMutation) ResetField(name string) error {
	switch name {
	case useraccount.FieldUserIdentity:
		m.ResetUserIdentity()
		return nil
	case useraccount.FieldAccount:
		m.ResetAccount()
		return nil
	case useraccount.FieldPassword:
		m.ResetPassword()
		return nil
	case useraccount.FieldSalt:
		m.ResetSalt()
		return nil
	case useraccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useraccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case useraccount.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserAccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserAccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserAccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserAccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserAccount unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserAccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserAccount edge %s", name)
}

// UserExtendMutation represents an operation that mutate the UserExtends
// nodes in the graph.
type UserExtendMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	user_identity *string
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserExtend, error)
}

var _ ent.Mutation = (*UserExtendMutation)(nil)

// userextendOption allows to manage the mutation configuration using functional options.
type userextendOption func(*UserExtendMutation)

// newUserExtendMutation creates new mutation for $n.Name.
func newUserExtendMutation(c config, op Op, opts ...userextendOption) *UserExtendMutation {
	m := &UserExtendMutation{
		config:        c,
		op:            op,
		typ:           TypeUserExtend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserExtendID sets the id field of the mutation.
func withUserExtendID(id int64) userextendOption {
	return func(m *UserExtendMutation) {
		var (
			err   error
			once  sync.Once
			value *UserExtend
		)
		m.oldValue = func(ctx context.Context) (*UserExtend, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserExtend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserExtend sets the old UserExtend of the mutation.
func withUserExtend(node *UserExtend) userextendOption {
	return func(m *UserExtendMutation) {
		m.oldValue = func(context.Context) (*UserExtend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserExtendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserExtendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on UserExtend creation.
func (m *UserExtendMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserExtendMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserIdentity sets the user_identity field.
func (m *UserExtendMutation) SetUserIdentity(s string) {
	m.user_identity = &s
}

// UserIdentity returns the user_identity value in the mutation.
func (m *UserExtendMutation) UserIdentity() (r string, exists bool) {
	v := m.user_identity
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIdentity returns the old user_identity value of the UserExtend.
// If the UserExtend object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserExtendMutation) OldUserIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserIdentity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIdentity: %w", err)
	}
	return oldValue.UserIdentity, nil
}

// ClearUserIdentity clears the value of user_identity.
func (m *UserExtendMutation) ClearUserIdentity() {
	m.user_identity = nil
	m.clearedFields[userextend.FieldUserIdentity] = struct{}{}
}

// UserIdentityCleared returns if the field user_identity was cleared in this mutation.
func (m *UserExtendMutation) UserIdentityCleared() bool {
	_, ok := m.clearedFields[userextend.FieldUserIdentity]
	return ok
}

// ResetUserIdentity reset all changes of the "user_identity" field.
func (m *UserExtendMutation) ResetUserIdentity() {
	m.user_identity = nil
	delete(m.clearedFields, userextend.FieldUserIdentity)
}

// SetCreatedAt sets the created_at field.
func (m *UserExtendMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserExtendMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the UserExtend.
// If the UserExtend object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserExtendMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of created_at.
func (m *UserExtendMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userextend.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field created_at was cleared in this mutation.
func (m *UserExtendMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userextend.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserExtendMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userextend.FieldCreatedAt)
}

// SetUpdatedAt sets the updated_at field.
func (m *UserExtendMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserExtendMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the UserExtend.
// If the UserExtend object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserExtendMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of updated_at.
func (m *UserExtendMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userextend.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updated_at was cleared in this mutation.
func (m *UserExtendMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userextend.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserExtendMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userextend.FieldUpdatedAt)
}

// SetDeletedAt sets the deleted_at field.
func (m *UserExtendMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserExtendMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the UserExtend.
// If the UserExtend object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserExtendMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserExtendMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userextend.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserExtendMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userextend.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *UserExtendMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userextend.FieldDeletedAt)
}

// Op returns the operation name.
func (m *UserExtendMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserExtend).
func (m *UserExtendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserExtendMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_identity != nil {
		fields = append(fields, userextend.FieldUserIdentity)
	}
	if m.created_at != nil {
		fields = append(fields, userextend.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userextend.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userextend.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserExtendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userextend.FieldUserIdentity:
		return m.UserIdentity()
	case userextend.FieldCreatedAt:
		return m.CreatedAt()
	case userextend.FieldUpdatedAt:
		return m.UpdatedAt()
	case userextend.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserExtendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userextend.FieldUserIdentity:
		return m.OldUserIdentity(ctx)
	case userextend.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userextend.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userextend.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserExtend field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserExtendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userextend.FieldUserIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIdentity(v)
		return nil
	case userextend.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userextend.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userextend.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserExtend field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserExtendMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserExtendMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserExtendMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserExtend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserExtendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userextend.FieldUserIdentity) {
		fields = append(fields, userextend.FieldUserIdentity)
	}
	if m.FieldCleared(userextend.FieldCreatedAt) {
		fields = append(fields, userextend.FieldCreatedAt)
	}
	if m.FieldCleared(userextend.FieldUpdatedAt) {
		fields = append(fields, userextend.FieldUpdatedAt)
	}
	if m.FieldCleared(userextend.FieldDeletedAt) {
		fields = append(fields, userextend.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserExtendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserExtendMutation) ClearField(name string) error {
	switch name {
	case userextend.FieldUserIdentity:
		m.ClearUserIdentity()
		return nil
	case userextend.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userextend.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userextend.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserExtend nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserExtendMutation) ResetField(name string) error {
	switch name {
	case userextend.FieldUserIdentity:
		m.ResetUserIdentity()
		return nil
	case userextend.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userextend.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userextend.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserExtend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserExtendMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserExtendMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserExtendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserExtendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserExtendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserExtendMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserExtendMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserExtend unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserExtendMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserExtend edge %s", name)
}

// UserInfoMutation represents an operation that mutate the UserInfos
// nodes in the graph.
type UserInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	user_identity *string
	channel       *int32
	addchannel    *int32
	form          *int32
	addform       *int32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserInfo, error)
}

var _ ent.Mutation = (*UserInfoMutation)(nil)

// userinfoOption allows to manage the mutation configuration using functional options.
type userinfoOption func(*UserInfoMutation)

// newUserInfoMutation creates new mutation for $n.Name.
func newUserInfoMutation(c config, op Op, opts ...userinfoOption) *UserInfoMutation {
	m := &UserInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeUserInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserInfoID sets the id field of the mutation.
func withUserInfoID(id int64) userinfoOption {
	return func(m *UserInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *UserInfo
		)
		m.oldValue = func(ctx context.Context) (*UserInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserInfo sets the old UserInfo of the mutation.
func withUserInfo(node *UserInfo) userinfoOption {
	return func(m *UserInfoMutation) {
		m.oldValue = func(context.Context) (*UserInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that, this
// operation is accepted only on UserInfo creation.
func (m *UserInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserIdentity sets the user_identity field.
func (m *UserInfoMutation) SetUserIdentity(s string) {
	m.user_identity = &s
}

// UserIdentity returns the user_identity value in the mutation.
func (m *UserInfoMutation) UserIdentity() (r string, exists bool) {
	v := m.user_identity
	if v == nil {
		return
	}
	return *v, true
}

// OldUserIdentity returns the old user_identity value of the UserInfo.
// If the UserInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserInfoMutation) OldUserIdentity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserIdentity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserIdentity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserIdentity: %w", err)
	}
	return oldValue.UserIdentity, nil
}

// ClearUserIdentity clears the value of user_identity.
func (m *UserInfoMutation) ClearUserIdentity() {
	m.user_identity = nil
	m.clearedFields[userinfo.FieldUserIdentity] = struct{}{}
}

// UserIdentityCleared returns if the field user_identity was cleared in this mutation.
func (m *UserInfoMutation) UserIdentityCleared() bool {
	_, ok := m.clearedFields[userinfo.FieldUserIdentity]
	return ok
}

// ResetUserIdentity reset all changes of the "user_identity" field.
func (m *UserInfoMutation) ResetUserIdentity() {
	m.user_identity = nil
	delete(m.clearedFields, userinfo.FieldUserIdentity)
}

// SetChannel sets the channel field.
func (m *UserInfoMutation) SetChannel(i int32) {
	m.channel = &i
	m.addchannel = nil
}

// Channel returns the channel value in the mutation.
func (m *UserInfoMutation) Channel() (r int32, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old channel value of the UserInfo.
// If the UserInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserInfoMutation) OldChannel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChannel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// AddChannel adds i to channel.
func (m *UserInfoMutation) AddChannel(i int32) {
	if m.addchannel != nil {
		*m.addchannel += i
	} else {
		m.addchannel = &i
	}
}

// AddedChannel returns the value that was added to the channel field in this mutation.
func (m *UserInfoMutation) AddedChannel() (r int32, exists bool) {
	v := m.addchannel
	if v == nil {
		return
	}
	return *v, true
}

// ResetChannel reset all changes of the "channel" field.
func (m *UserInfoMutation) ResetChannel() {
	m.channel = nil
	m.addchannel = nil
}

// SetForm sets the form field.
func (m *UserInfoMutation) SetForm(i int32) {
	m.form = &i
	m.addform = nil
}

// Form returns the form value in the mutation.
func (m *UserInfoMutation) Form() (r int32, exists bool) {
	v := m.form
	if v == nil {
		return
	}
	return *v, true
}

// OldForm returns the old form value of the UserInfo.
// If the UserInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserInfoMutation) OldForm(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldForm is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldForm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForm: %w", err)
	}
	return oldValue.Form, nil
}

// AddForm adds i to form.
func (m *UserInfoMutation) AddForm(i int32) {
	if m.addform != nil {
		*m.addform += i
	} else {
		m.addform = &i
	}
}

// AddedForm returns the value that was added to the form field in this mutation.
func (m *UserInfoMutation) AddedForm() (r int32, exists bool) {
	v := m.addform
	if v == nil {
		return
	}
	return *v, true
}

// ResetForm reset all changes of the "form" field.
func (m *UserInfoMutation) ResetForm() {
	m.form = nil
	m.addform = nil
}

// SetCreatedAt sets the created_at field.
func (m *UserInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *UserInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old created_at value of the UserInfo.
// If the UserInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of created_at.
func (m *UserInfoMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userinfo.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the field created_at was cleared in this mutation.
func (m *UserInfoMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userinfo.FieldCreatedAt]
	return ok
}

// ResetCreatedAt reset all changes of the "created_at" field.
func (m *UserInfoMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userinfo.FieldCreatedAt)
}

// SetUpdatedAt sets the updated_at field.
func (m *UserInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *UserInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old updated_at value of the UserInfo.
// If the UserInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of updated_at.
func (m *UserInfoMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userinfo.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the field updated_at was cleared in this mutation.
func (m *UserInfoMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userinfo.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt reset all changes of the "updated_at" field.
func (m *UserInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userinfo.FieldUpdatedAt)
}

// SetDeletedAt sets the deleted_at field.
func (m *UserInfoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the deleted_at value in the mutation.
func (m *UserInfoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old deleted_at value of the UserInfo.
// If the UserInfo object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserInfoMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of deleted_at.
func (m *UserInfoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userinfo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the field deleted_at was cleared in this mutation.
func (m *UserInfoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userinfo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt reset all changes of the "deleted_at" field.
func (m *UserInfoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userinfo.FieldDeletedAt)
}

// Op returns the operation name.
func (m *UserInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserInfo).
func (m *UserInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserInfoMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_identity != nil {
		fields = append(fields, userinfo.FieldUserIdentity)
	}
	if m.channel != nil {
		fields = append(fields, userinfo.FieldChannel)
	}
	if m.form != nil {
		fields = append(fields, userinfo.FieldForm)
	}
	if m.created_at != nil {
		fields = append(fields, userinfo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userinfo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userinfo.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userinfo.FieldUserIdentity:
		return m.UserIdentity()
	case userinfo.FieldChannel:
		return m.Channel()
	case userinfo.FieldForm:
		return m.Form()
	case userinfo.FieldCreatedAt:
		return m.CreatedAt()
	case userinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case userinfo.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userinfo.FieldUserIdentity:
		return m.OldUserIdentity(ctx)
	case userinfo.FieldChannel:
		return m.OldChannel(ctx)
	case userinfo.FieldForm:
		return m.OldForm(ctx)
	case userinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userinfo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserInfo field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userinfo.FieldUserIdentity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserIdentity(v)
		return nil
	case userinfo.FieldChannel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case userinfo.FieldForm:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForm(v)
		return nil
	case userinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userinfo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserInfoMutation) AddedFields() []string {
	var fields []string
	if m.addchannel != nil {
		fields = append(fields, userinfo.FieldChannel)
	}
	if m.addform != nil {
		fields = append(fields, userinfo.FieldForm)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userinfo.FieldChannel:
		return m.AddedChannel()
	case userinfo.FieldForm:
		return m.AddedForm()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userinfo.FieldChannel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChannel(v)
		return nil
	case userinfo.FieldForm:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForm(v)
		return nil
	}
	return fmt.Errorf("unknown UserInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userinfo.FieldUserIdentity) {
		fields = append(fields, userinfo.FieldUserIdentity)
	}
	if m.FieldCleared(userinfo.FieldCreatedAt) {
		fields = append(fields, userinfo.FieldCreatedAt)
	}
	if m.FieldCleared(userinfo.FieldUpdatedAt) {
		fields = append(fields, userinfo.FieldUpdatedAt)
	}
	if m.FieldCleared(userinfo.FieldDeletedAt) {
		fields = append(fields, userinfo.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserInfoMutation) ClearField(name string) error {
	switch name {
	case userinfo.FieldUserIdentity:
		m.ClearUserIdentity()
		return nil
	case userinfo.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userinfo.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userinfo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserInfoMutation) ResetField(name string) error {
	switch name {
	case userinfo.FieldUserIdentity:
		m.ResetUserIdentity()
		return nil
	case userinfo.FieldChannel:
		m.ResetChannel()
		return nil
	case userinfo.FieldForm:
		m.ResetForm()
		return nil
	case userinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userinfo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserInfo unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserInfo edge %s", name)
}
